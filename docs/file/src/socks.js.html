<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/socks.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/socks.js~hub.html">hub</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-$socks">$socks</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/socks.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* jshint browser: true, asi: true, laxcomma: true, esversion: 6 */
/* globals console */

&apos;use strict&apos;

import uuid from &apos;uuid&apos;

// brought this in as a vue at first so I could do events based on the the subs
// and requests

class hub {
    /**
     * @desc hub constructor, sets up config for backoff, WebSocket creation,
     * internal message buffer, does some light sanity checking.
     *
     * @param {Object} opts
     * @param {!string} opts.url - Server endpoint hosting websocket
     * @param {string} [opts.subscribePath=&apos;/api/join&apos;] - Server side message endpoint that
     * services channel subscriptions.
     * @param {number} [opts.factor=200] - Backoff step factor (&quot;to be increased by&quot;)
     * @param {number} [opts.max=2000] - Ceiling for backoff wait time
     */
    constuctor (opts) {
        // {
        //  chan: [sub, sub, sub] &lt;- each sub func expects the message payload from the socket message
        // }

        /*
         * @access private
         */
        this.subscriptions = {}

        // {
        //  reqId: (resp) =&gt; {}
        // }
        /* @access private */
        this.requests = {}

        if (!opts.url) throw new Error(&apos;Hub: no url passed for socket connection. Ejecting.&apos;)

        this.url = opts.url

        /* @access private */
        this.backoff = 0

        /* @access private */
        this.factor = opts.factor || 200
        /* @access private */
        this.max = opts.max || 2000

        this.sock = null
        /* @access private */
        this.sockOpen = false

        if (!opts.subscribePath) console.warn(&apos;Hub: no `subscribePath` option set, using default `/api/join`&apos;)

        this.subscribePath = opts.subscribePath || &apos;/api/join&apos;

        this._bufferedMessages = []
    }

    // TODO make this &quot;private&quot;

    /**
     * @desc Create a new websocket and hold the ref to it internally. Also
     * decorates the new `WebSocket` with a `write` method to serialized outgoing
     * messages.
    */
    makeSocket () {
        try {
            this.sock = new WebSocket(this.url)

        } catch (e) {
            console.warn(e)
            console.warn(&apos;attempting to establish connection again&apos;)

            setTimeout(() =&gt; {
                // allegedly not actually recursive (does not grow infinistack)
                this.makeSocket(this.url)
            }, 500)
        }

        this.sock.write = this.write.bind(this) // hrmmmm

        if (this._bufferedMessages.length) {
            // these have alread been serialized
            let data

            while ((data = this._bufferedMessages.pop())) {
                this.sock.write(data)
            }
        }

        this.sock.onopen = () =&gt; {
            console.info(&apos;socket open&apos;)
        }

        this.sock.onclose = (ev) =&gt; {
            console.info(&apos;socket close event&apos;, ev)
        }

        this.sock.onerror = (ev) =&gt; {
            console.error(&apos;socket error event&apos;, ev)
        }

        this.sock.onmessage = this.handle
    }

    // context of .write method bound to instance of hub forcibly with .bind call

    /**
     * @desc Serialize and write data to WebSocket. Has been attached to WebSocket
     * object via a `bind` call, binding its context to that of the hub instance.
     * @param {any} data - serializeable object to be sent across socket
    */
    write (data) {
        let msg

        // the flow of making a connection needs to be audited
        // this sort of check is required in too many places
        if (!this.sock) {
            this.makeSocket(this.url)
        }

        if (this.sock.readyState === this.sock.OPEN) {
            try {
                msg = JSON.stringify(data)
            } catch (e) {
                // TODO error hub thing
                throw e
            }

            this.backoff = 0
            this.sock.send(msg)

        } else if (this.sock.readyState === this.sock.CONNECTING) {
            console.warn(&apos;socket still connecting, retry in a tick&apos;)

            setTimeout(() =&gt; {
                this.sock.write(data)
            }, 100)

        } else {
            console.warn(`socket disconnected, retry in a bit: ${this.backoff}`)

            this._bufferedMessages.unshift(data)

            this.sock = null

            setTimeout(() =&gt; {
                this.backoff = this.backoff + 1 * this.factor
                this.backoff = this.backoff &lt;= this.max ? this.backoff : this.max

                this.makeSocket(this.url)
            }, this.backoff)
        }
    }

    /**
     * @access private
    */
    handle (ev) {
        let data = this.read(ev)

        if (data.requestId) {
            data.pending = false

            let handler = this.requests[data.requestId]

            if (handler) {
                handler(data)
                delete this.requests[data.requestId]
            } else {
                console.warn(`pipeline:orphaned_response - no handler`, data)
            }

        } else if (data.channel) {
            let subs = this.subscriptions[data.channel] // [func, func, func]

            if (subs) {
                subs.forEach(sub =&gt; sub(data))
            }
        }
    }

    /**
     * @desc Write a message to the server expecting a response to come back keyed
     * with the same `requestId` as aformentioned write.
     *
     * @param {object} req - Request object to be written to WebSocket. Will be
     * deocorated with `uuid.v1` and `pending = true`.
     *
     * @return {Promise} Rejects if `error` property present on payload from
     * server, resolves otherwise.
     */
    request (req) {
        req.requestId = uuid.v1()
        req.pending = true

        let promise = new Promise(function (resolve, reject) {
            // register a callback that will recieve the response data from the
            // request and finish the promise with it
            this.requests[req.requestId] = function (response) {
                if (response.error) reject(response)
                else resolve(response)
            }
        })

        if (this.sock)
            this.sock.write(req)
        else {
            this.makeSocket()
            this.sock.write(req)
        }

        return promise
    }

    /**
     * @desc Initiate write to WebSocket to communicate interest in subscribing to
     * messages across a given channel. Pass `subscribePath` as option to
     * constructor to configure &quot;endpoint&quot; used to initiate subscription on server.
     *
     * @param {string} channel - Name of channel, to be send on `body.channel`
     * property of outgoing message.
     *
     * @param {string} topic - Optional topic in channel, could be used as a sort of
     * subcategory of interest.
     *
     * @param {function(msgData: Object)} cb - Callback to be invoked on each message written to
     * channel by server.
     */
    subscribe (channel, topic, cb) {
        // arg snip
        if (typeof topic === &apos;function&apos;) {
            cb = topic
            topic = null
        }

        if (this.sock) {
            this.sock.write({
                path: this.subscribePath,
                body: { channel }
            })
        } else {
            this.makeSocket()
            this.sock.write({
                path: this.subscribePath,
                body: { channel }
            })
        }

        this.subscriptions[channel] = this.subscriptions[channel] || []

        let subs = this.subscriptions[channel]

        if (subs.indexOf(cb) === -1)
            subs.push(cb)
    }

    // TODO finer grained unsub control? unsub from topic, not from whole channel?

    /**
     * @desc Send message to server indicating desire to unsubscribe from given
     * channel.
     *
     * @param {string} channel - Name of channel to unsub from.
     *
     * @param {function} cb - Reference to the callback originally passed on
     * subscription creation.
    */
    unsubscribe (channel, cb) {
        this.sock.write({
            path: this.subscribePath,
            body: { channel }
        })

        if (!cb) {
            console.error(&apos;pipeline:$unsubscribe - method requires reference to original callback as second arg&apos;)
            return
        }

        let subs = this.subscriptions[channel]

        let index = subs.indexOf(cb)

        if (index !== -1)
            subs.splice(index, 1)
        else {
            console.error(&apos;pipeline:$unsubscribe - subscription callback not found in channel&apos;)
        }

        if (subs.length === 0) {
            delete this.subscriptions[channel]
        }
    }

    /**
     * @access private
    */
    read (msg) {
        try {
            let data = JSON.parse(msg.data)
            return data
        } catch (e) {
            // TODO error hub thing
            throw e
        }
    }
}

export default hub
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
